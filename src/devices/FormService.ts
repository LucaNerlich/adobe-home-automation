import {getRandomID} from '../constants'
import {createDeviceWithFormData} from './DeviceService'
import {DeviceType} from './DeviceType'
import {getConsumerTopicSelect, getFormDataAttribute, replaceSpaceWithDash, setDataAttribute} from '../domUtils'
import {useRegistryService} from './RegistryService'
import {StrategyType} from './strategies/StrategyType'

export const TOPIC_FORM_NAME = 'topic'
export const CONSUMER_FORM_NAME = 'name'
export const STRATEGIES_FORM_NAME = 'strategies'

/**
 * This function creates a submit button with a provided label.
 *
 * @param  {string} label - The label to use for the submission button value.
 * @returns {HTMLInputElement} A submit button element which has been set up with the specified label.
 */
export function createSubmit(label: string) {
    const submit = document.createElement('input')
    setDataAttribute(submit, getFormDataAttribute('submit_' + replaceSpaceWithDash(label)))
    submit.setAttribute('type', 'submit')
    submit.setAttribute('value', label)
    return submit
}

/**
 * This function creates an HTML `<option>` element from a provided string label. 
 * The option element is given both a value and display text from the label. If the label includes the substring "_STRATEGY",
 * it will be removed from the display text but not the value.
 * The function also uses helper functions to set appropriate data-attributes for the created element.
 *
 * @param {string} label - The option label that will be used as the display and value for the created HTML <option> element.
 * @returns {HTMLElement} An HTML `option` element with appropriate attribute settings, ready for insertion into a select menu.
 */
export function createSelectOption(label: string): HTMLElement {
    const optionElement = document.createElement('option')
    setDataAttribute(optionElement, getFormDataAttribute('select-option_' + replaceSpaceWithDash(label)))
    optionElement.setAttribute('value', label)
    optionElement.textContent = label.replace('_STRATEGY', '')

    return optionElement
}

/**
 * The `addStrategySelectToForm` function dynamically generates an HTML select element containing options for strategy types used in the application.
 * The created select element is then appended to a specified form.
 *
 * @param formRoot   The HTMLFormElement to which the created select element will be appended. The function creates multiple DOM elements,
 *                   which it sequentially appends to `formRoot`. 
 *                   These include a line break, a label, and the strategy selection dropdown.
 *
 * Before appending to the form, the function uses `StrategyType` to generate a list of options for the user to choose from in the form.
 * This is implemented through a filter-map pattern, filtering out any non-numeric keys in the `StrategyType` enum and creating select 
 * options for each remaining valid `StrategyType`.
 *
 * The new select element carries an ID generated by the `getRandomID` function, an attribute name set to STRATEGIES_FORM_NAME, 
 * and a data attribute set via `getFormDataAttribute` function with the string "strategy-select".
 * The corresponding label carries a 'for' attribute matching the select element's ID, a text content set as 'Use Case', 
 * and a data attribute value generated the same way but with "strategy-select-label".
 */
function addStrategySelectToForm(formRoot: HTMLFormElement) {
    formRoot.appendChild(document.createElement('br'))

    const strategyId = getRandomID()
    const strategyLabel = document.createElement('label')
    setDataAttribute(strategyLabel, getFormDataAttribute('strategy-select-label'))
    strategyLabel.setAttribute('for', strategyId)
    strategyLabel.textContent = 'Use Case'
    formRoot.appendChild(strategyLabel)

    const strategyInput = document.createElement('select')
    setDataAttribute(strategyInput, getFormDataAttribute('strategy-select'))
    strategyInput.id = strategyId
    strategyInput.setAttribute('name', STRATEGIES_FORM_NAME)

    // https://bobbyhadz.com/blog/typescript-iterate-enum
    Object.keys(StrategyType).filter((v) => isNaN(Number(v))).forEach(strategyType => {
            strategyInput.appendChild(createSelectOption(strategyType))
        },
    )

    formRoot.appendChild(strategyInput)
}

/**
 * The `addTopicSelectToForm` function dynamically generates an HTML select element containing a list of available topics. 
 * The created select element is then appended to a specified form.
 *
 * @param formRoot   The HTMLFormElement to which the created select element will be appended. The function creates multiple DOM elements,
 *                   which it sequentially appends to `formRoot`. These include a line break, a label, and the topic selection dropdown.
 *
 * Before appending to the form, the function uses the `registryService.getAllTopics` method to retrieve all available topics in the application. 
 * This is implemented through a forEach statement, appending each topic as an option in the selection dropdown via the `createSelectOption` function.
 *
 * The new select element carries an ID generated by the `getRandomID` function, an attribute name set to TOPIC_FORM_NAME, 
 * and a data attribute set via `getFormDataAttribute` function with the string "consumer-topic-select".
 * The corresponding label carries a 'for' attribute matching the select element's ID, a text content set as 'Available Topics', 
 * and a data attribute value generated the same way but with "consumer-topic-label".
 */
function addTopicSelectToForm(formRoot: HTMLFormElement) {
    const registryService = useRegistryService()
    formRoot.appendChild(document.createElement('br'))

    const topicSelectId = getRandomID()
    const topicSelectLabel = document.createElement('label')
    setDataAttribute(topicSelectLabel, getFormDataAttribute('consumer-topic-label'))
    topicSelectLabel.setAttribute('for', topicSelectId)
    topicSelectLabel.textContent = 'Available Topics'
    formRoot.appendChild(topicSelectLabel)

    const strategySelectInput = document.createElement('select')
    setDataAttribute(strategySelectInput, getFormDataAttribute('consumer-topic-select'))
    strategySelectInput.id = topicSelectId
    strategySelectInput.setAttribute('name', TOPIC_FORM_NAME)

    registryService.getAllTopics().forEach((_count, topic) => {
        strategySelectInput.appendChild(createSelectOption(topic))
    })

    formRoot.appendChild(strategySelectInput)
}

/**
 * This function creates an error span element for the form that displays a specified error message.
 * 
 * @param  {string} message - The error message to be displayed in the error span.
 * @returns {HTMLElement} Span element, with 'role' attribute set to 'error', id set using a generated 
 * random ID, display style set to 'none', color set to 'red', and text content set to provided `message`. 
 * The span is hidden by default and its visibility can be toggled to display the error message.
 */
function generateErrorSpan(message: string) {
    const submitErrorId = getRandomID()
    const submitErrorSpan = document.createElement('span')
    submitErrorSpan.setAttribute('role', 'error')
    submitErrorSpan.id = submitErrorId
    submitErrorSpan.style.display = 'none'
    submitErrorSpan.style.color = 'red'
    submitErrorSpan.textContent = message

    return submitErrorSpan
}

/**
 * `generateProviderForm` is a function responsible for dynamically generating a provider form based on a passed HTML form root.
 *
 * @param {HTMLFormElement | null} formRoot - the HTML form element where the provider form should be appended.
 *
 * The function uses the `useRegistryService` to organize and validate the topic field in the form.
 * After which, it generates and builds the provider form in a particular order along with a submit and error notification functionality.
 *
 * Following a successful form validation, the function goes ahead to:
 * - Hide the error span
 * - Reset the form
 * - Create a new provider device with form data
 *
 * The essence of this method is routed towards creating a new topic value, appending it to the consumer topic selection,
 * and producing new provider form through the device creation process.
 */
export function generateProviderForm(formRoot: HTMLFormElement | null) {
    const registryService = useRegistryService()

    if (formRoot) {
        const labelInputTuple = generateLabelTextInput('Topic', 'provider-topic', TOPIC_FORM_NAME)

        // build the form in order
        formRoot.appendChild(labelInputTuple[0])
        formRoot.appendChild(labelInputTuple[1])
        addStrategySelectToForm(formRoot)

        const submit = createSubmit('Add Provider')
        const submitErrorSpan = generateErrorSpan('Invalid: Duplicate Topic')
        formRoot.appendChild(submit)
        formRoot.appendChild(submitErrorSpan)

        // on submit
        formRoot.addEventListener('submit', (event) => {
            event.preventDefault()

            const form = event.target as HTMLFormElement
            const formData = new FormData(form)

            // validate provider form
            let isValid = true
            let topic = ''
            formData.forEach((value, key) => {
                if (key === TOPIC_FORM_NAME) {
                    topic = replaceSpaceWithDash(value.toString())

                    registryService.addTopic(topic, () => {
                        // add the new topic to the consumer topic select options
                        const topicSelect = getConsumerTopicSelect()
                        topicSelect?.appendChild(createSelectOption(topic))
                    })
                    isValid = true
                }
            })

            if (isValid) {
                submitErrorSpan.style.display = 'none'
                form.reset()

                // create and add new provider
                createDeviceWithFormData(formData, DeviceType.PROVIDER)
            }
        })
    }
}

/**
 * This function create a label HTML element with the specified parameters.
 *
 * @param {string} id - The id value for the 'for' attribute of the 'label' element.
 * @param {string} label - The text content of the 'label' element.
 * @param {string} [type] - An optional type parameter to modify the data attribute of the label. If not provided, label param is used.
 * @returns {HTMLElement} A 'label' HTML element with attributes set according to function parameters.
 */
export function createLabelElement(id: string, label: string, type?: string): HTMLElement {
    const labelElement = document.createElement('label')
    labelElement.setAttribute('for', id)
    setDataAttribute(labelElement, getFormDataAttribute((type ? type : label) + '-label'))
    labelElement.textContent = label
    return labelElement
}

/**
 * `createInputElement` is a function that creates an HTML `input` element. It sets the element's id, data attribute, and type.
 *
 * @param {string} id - String to use as the ID of the newly created `input` element.
 * @param {string} dataAttribute - String to use to set a custom data attribute of the `input` element using the helper function `getFormDataAttribute`.
 * @param {string} type - Specifies the input type of the created `input` element.
 * 
 * @returns {HTMLElement} - Returns an HTML input element with the provided id, type and data attribute settings.
 */
export function createInputElement(id: string, dataAttribute: string, type: string): HTMLElement {
    const inputElement = document.createElement('input')
    inputElement.id = id
    setDataAttribute(inputElement, getFormDataAttribute(dataAttribute + '-input'))
    inputElement.setAttribute('type', type)

    return inputElement
}

/**
 * This function generates two HTML elements: a Label and a TextInput both related to each other by their ids.
 * It takes in three parameters: label, type, and name.
 *
 * @param {string} label - The label string will act as inner text of the created label element, and also as placeholder of the TextInput.
 * @param {string} type - The type string will be an attribute for both created elements.
 * @param {string} name - The name string will be set as attribute 'name' to the generated TextInput. 
 * @returns {[HTMLElement, HTMLElement]} It returns an array of two HTML elements: labelElement and inputElement, in that order.
 */
function generateLabelTextInput(label: string, type: string, name: string): [HTMLElement, HTMLElement] {
    const labelId = getRandomID()
    const labelElement = createLabelElement(labelId, label, type)

    const inputElement = createInputElement(labelId, type, 'text')
    inputElement.setAttribute('name', name)
    inputElement.setAttribute('placeholder', label)
    inputElement.setAttribute('required', 'true')

    return [labelElement, inputElement]
}

/**
 * This function `generateConsumerForm` handles the creation and insertion of form elements within a given form root element.
 * It constructs a consumer form to be used in a web application, appending necessary form components, such as text inputs,
 * selection dropdowns, and a submit button, into the provided form root.
 *
 * @param {HTMLFormElement | null} formRoot - The root form element to which the consumer form components are appended.
 * If the provided root is null, the function will simply return without creating and appending the consumer form.
 * 
 * NOTE: This function depends on the existence of several helper functions like `createSubmit`, `addTopicSelectToForm`,
 * `addStrategySelectToForm`, etc at runtime. Make sure these dependencies are satisfied for this function to work properly.
 * Also, it references a few constants such as CONSUMER_FORM_NAME that need to be pre-defined in the same scope.
 */
export function generateConsumerForm(formRoot: HTMLFormElement | null) {
    if (formRoot) {
        // reset form children
        formRoot.innerHTML = ''

        const labelInputTupel = generateLabelTextInput('Name', 'consumer-name', CONSUMER_FORM_NAME)
        formRoot.appendChild(labelInputTupel[0])
        formRoot.appendChild(labelInputTupel[1])

        addTopicSelectToForm(formRoot)
        addStrategySelectToForm(formRoot)

        const submit = createSubmit('Add Consumer')
        formRoot.appendChild(submit)

        const submitErrorSpan = generateErrorSpan('Invalid: Name cannot be empty.')
        formRoot.appendChild(submitErrorSpan)

        // on submit
        formRoot.addEventListener('submit', (event) => {
            event.preventDefault()
            const form = event.target as HTMLFormElement
            const formData = new FormData(form)

            // validate consumer form
            let isValid = true
            formData.forEach((value, key) => {
                if (key === CONSUMER_FORM_NAME) {
                    if (value.toString().trim().length === 0) {
                        submitErrorSpan.style.display = ''
                        isValid = false
                    } else {
                        isValid = true
                    }
                }
            })

            if (isValid) {
                submitErrorSpan.style.display = 'none'
                form.reset()
                // create and add new consumer
                createDeviceWithFormData(formData, DeviceType.CONSUMER)
            }
        })
    }
}
